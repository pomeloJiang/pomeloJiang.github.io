<!DOCTYPE html>
<html lang="zh-CN">
<head><meta name="generator" content="Hexo 3.8.0">
    <meta charset="UTF-8">

    

    

    <title>Android Framework之Activity启动流程(一) | 柚子 | pomeloJiang</title>
    <meta name="author" content="pomeloJiang">
    <meta name="version" content="1.0.0">
    <meta name="keywords" content="Android | Java | 算法">
    <meta name="description" content="本文的分析基于Android 8.1源码。本文章将分三篇为大家讲解。第二篇：Android Framework之Activity启动流程(二)第三篇：Android Framework之Activity启动流程(三)在文章的起始，插张时序图,先看结论再看过程。（右键-新标签页打开）Zygote在Android系统中，是由ActivityManagerService负责为应用程序创建新进程的。至于ActivityManagerService本身进程，则是由Zygote负责启动。Zygo...">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no">

    
    <link rel="alternate" href="/atom.xml" title="柚子 | pomeloJiang" type="application/atom+xml">
    
    
    <link rel="icon" href="/images/favicon.ico">
    

    <link rel="stylesheet" href="/css/style.css">
</head>
<body>

    <main class="app">
        <header class="header clearfix">
    <div id="nav" class="nav">
    <div class="nav-mobile">
        <button id="open-panel" class="open-panel nav-mobile-item"><i class="icon-documents"></i></button>
        <h1 class="nav-mobile-title nav-mobile-item">柚子 | pomeloJiang</h1>
        <button id="open-menus" class="open-panel nav-mobile-item"><i class="icon-library"></i></button>
    </div>

    <nav id="nav-inner" class="nav-inner">
        
            <a class="nav-item" href="/">
                <span class="nav-text">Home</span>
            </a>
        
            <a class="nav-item" href="/categories/android">
                <span class="nav-text">Android</span>
            </a>
        
            <a class="nav-item" href="/categories/java">
                <span class="nav-text">Java</span>
            </a>
        
            <a class="nav-item" href="/categories/notes">
                <span class="nav-text">Notes</span>
            </a>
        
            <a class="nav-item" href="/categories/chat">
                <span class="nav-text">Chat</span>
            </a>
        
            <a class="nav-item" href="/archives">
                <span class="nav-text">Archives</span>
            </a>
        
            <a class="nav-item" href="/about">
                <span class="nav-text">About</span>
            </a>
        
    </nav>
</div>

    <aside id="aside" class="aside">
    <div id="aside-mask" class="aside-mask"></div>
    <div id="aside-inner" class="aside-inner">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit"><i class="icon-search-stroke"></i></button><input type="hidden" name="sitesearch" value="http://pomelojiang.github.io"></form>

        
        
        
        

        
        <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Zygote"><span class="toc-number">1.</span> <span class="toc-text">Zygote</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Context-startActivity"><span class="toc-number">2.</span> <span class="toc-text">Context.startActivity()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Instrumentation"><span class="toc-number">3.</span> <span class="toc-text">Instrumentation</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ActivityManagerService"><span class="toc-number">4.</span> <span class="toc-text">ActivityManagerService</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ActivityStarter"><span class="toc-number">5.</span> <span class="toc-text">ActivityStarter</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ActivityStackSupervisor、ActivityStack"><span class="toc-number">6.</span> <span class="toc-text">ActivityStackSupervisor、ActivityStack</span></a></li></ol>
        
    </div>
</aside>

</header>

        <div id="content" class="content"><article class="article" itemscope="" itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            Android Framework之Activity启动流程(一)
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="http://pomelojiang.github.io/android_framework_start_activity_1.html">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2018-12-05T07:21:00.301Z" itemprop="datePublished">2018-12-05</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/tags/Android/">Android</a>, <a class="article-tag-link" href="/tags/Frameworks/">Frameworks</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <p><br><br><em><font size="4px" color="#555555">本文的分析基于Android 8.1源码。</font></em><br><br>本文章将分三篇为大家讲解。<br>第二篇：<a href="https://pomelojiang.github.io/android_framework_start_activity_2">Android Framework之Activity启动流程(二)</a><br>第三篇：<a href="https://pomelojiang.github.io/android_framework_start_activity_3">Android Framework之Activity启动流程(三)</a></p>
<p>在文章的起始，插张时序图,先看结论再看过程。（右键-新标签页打开）<br><a id="more"></a><br><img src="../images/2018-04-26_start_activity.png" alt="Activity启动过程时序图"></p>
<p><br><br><br></p>
<h2 id="Zygote"><a href="#Zygote" class="headerlink" title="Zygote"></a>Zygote</h2><p>在Android系统中，是由ActivityManagerService负责为应用程序创建新进程的。至于ActivityManagerService本身进程，则是由Zygote负责启动。<br>Zygote翻译成中文，是受精卵。至于为啥叫这个名字，问设计Android系统的攻城狮去……<br>哈哈哈，开个玩笑。。。<br><img src="https://img-blog.csdn.net/20180412202107438?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuY2xlUG9tZWxv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""><br>在Android中，大部分的应用进程都是由zygote来创建的，是不是跟受精卵的职责有点类似, emmm……<br>我们来看看Zygote是如何创建ActivityManagerService进程的。</p>
<p>frameworks/base/core/java/com/android/internal/os/ZygoteInit.java</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String argv[])</span> </span>&#123;</span><br><span class="line">	……</span><br><span class="line">	<span class="comment">//这句话大概可以猜出zygote和其他进程是通过Socket来通信的</span></span><br><span class="line">  zygoteServer.registerServerSocket(socketName);</span><br><span class="line">  ……</span><br><span class="line">  <span class="keyword">boolean</span> startSystemServer = <span class="keyword">false</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; argv.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">"start-system-server"</span>.equals(argv[i])) &#123;</span><br><span class="line">          startSystemServer = <span class="keyword">true</span>;</span><br><span class="line">          ……</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> &#123;</span><br><span class="line">        &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  ……</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (startSystemServer) &#123;</span><br><span class="line">    <span class="comment">//在forkSystemServer中fork system server进程</span></span><br><span class="line">    Runnable r = forkSystemServer(abiList, socketName, zygoteServer);</span><br><span class="line">    ……</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Prepare the arguments and forks for the system server process.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Returns an &#123;<span class="doctag">@code</span> Runnable&#125; that provides an entrypoint into system_server code in the</span></span><br><span class="line"><span class="comment"> * child process, and &#123;<span class="doctag">@code</span> null&#125; in the parent.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Runnable <span class="title">forkSystemServer</span><span class="params">(String abiList, String socketName,</span></span></span><br><span class="line"><span class="function"><span class="params">        ZygoteServer zygoteServer)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// …… 我是可爱的省略号 (*╹▽╹*)</span></span><br><span class="line">        <span class="keyword">int</span> pid;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            parsedArgs = <span class="keyword">new</span> ZygoteConnection.Arguments(args);</span><br><span class="line">            ZygoteConnection.applyDebuggerSystemProperty(parsedArgs);</span><br><span class="line">            ZygoteConnection.applyInvokeWithSystemProperty(parsedArgs);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Request to fork the system server process */</span></span><br><span class="line">        <span class="comment">//重点来了,通过Zygote的静态方法来fork sytem server进程</span></span><br><span class="line">            pid = Zygote.forkSystemServer(</span><br><span class="line">                    parsedArgs.uid, parsedArgs.gid,</span><br><span class="line">                    parsedArgs.gids,</span><br><span class="line">                    parsedArgs.debugFlags,</span><br><span class="line">                    <span class="keyword">null</span>,</span><br><span class="line">                    parsedArgs.permittedCapabilities,</span><br><span class="line">                    parsedArgs.effectiveCapabilities);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalArgumentException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(ex);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* For child process */</span></span><br><span class="line">        <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (hasSecondZygote(abiList)) &#123;</span><br><span class="line">                waitForSecondaryZygote(socketName);</span><br><span class="line">            &#125;</span><br><span class="line">            zygoteServer.closeServerSocket();</span><br><span class="line">            <span class="keyword">return</span> handleSystemServerProcess(parsedArgs);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来就不进去看了，贴个Zygote.forkSystemServer方法的注释吧</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">     * Special method to start the system server process. In addition to the</span><br><span class="line">     * common actions performed in forkAndSpecialize, the pid of the child</span><br><span class="line">     * process is recorded such that the death of the child process will cause</span><br><span class="line">     * zygote to exit.</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>
<p>SystemServer进程启动时，会顺带初始化ActivityManagerService，代码这里就不贴了，大家自己去搜就行。<br>路径：frameworks/base/services/java/com/android/server/SystemServer.java<br>搜索关键字： ActivityManagerService</p>
<p><br><br><br></p>
<h2 id="Context-startActivity"><a href="#Context-startActivity" class="headerlink" title="Context.startActivity()"></a>Context.startActivity()</h2><p>当我们需要打开一个Activity时，是不是经常这样干。<br>这里的Context并不是Context类，真正干活的是ContextImpl。<br>我们来看看具体的代码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startActivity</span><span class="params">(Intent intent, Bundle options)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ……我是省略号</span></span><br><span class="line">    mMainThread.getInstrumentation().execStartActivity(</span><br><span class="line">            getOuterContext(), mMainThread.getApplicationThread(), <span class="keyword">null</span>,</span><br><span class="line">            (Activity) <span class="keyword">null</span>, intent, -<span class="number">1</span>, options);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><br><br><br></p>
<h2 id="Instrumentation"><a href="#Instrumentation" class="headerlink" title="Instrumentation"></a>Instrumentation</h2><p>ContextImpl又雇佣了Instrumentation来帮它干活。<br>来看看具体的细节：<br>frameworks/base/core/java/android/app/Instrumentation.java<br>看看官方对Instrumentation的解释：<br><a href="https://developer.android.com/reference/android/app/Instrumentation.html" target="_blank" rel="noopener">https://developer.android.com/reference/android/app/Instrumentation.html</a><br>没有梯子的小伙伴们 <a href="https://developer.android.google.cn/reference/android/app/Instrumentation.html" target="_blank" rel="noopener"><strong>请点我</strong></a><br>简单来说，Instrumentation最主要的作用就是监控系统和应用的交互<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ActivityResult <span class="title">execStartActivity</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        Context who, IBinder contextThread, IBinder token, Activity target,</span></span></span><br><span class="line"><span class="function"><span class="params">        Intent intent, <span class="keyword">int</span> requestCode, Bundle options)</span> </span>&#123;</span><br><span class="line">    IApplicationThread whoThread = (IApplicationThread) contextThread;</span><br><span class="line">   <span class="comment">//……省略代码</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//……省略代码</span></span><br><span class="line">		<span class="comment">//关键，通过Binder实现进程间通信</span></span><br><span class="line">		<span class="comment">//api26以前，这里应该通过ActivityManagerNative中的ActivityManagerProxy来获得AMS的代理对象</span></span><br><span class="line">		<span class="comment">//ActivityManagerNative.getDefault().startActivity();</span></span><br><span class="line">		<span class="comment">//在api26以上，ActivityManagerProxy以及被弃用，取而代之的是以下这句</span></span><br><span class="line">        <span class="keyword">int</span> result = ActivityManager.getService()</span><br><span class="line">            .startActivity(whoThread, who.getBasePackageName(), intent,</span><br><span class="line">                    intent.resolveTypeIfNeeded(who.getContentResolver()),</span><br><span class="line">                    token, target != <span class="keyword">null</span> ? target.mEmbeddedID : <span class="keyword">null</span>,</span><br><span class="line">                    requestCode, <span class="number">0</span>, <span class="keyword">null</span>, options);</span><br><span class="line">        checkStartActivityResult(result, intent);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Failure from system"</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们看看ActivityManager.getService()方法<br>frameworks/base/core/java/android/app/ActivityManager.java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> IActivityManager <span class="title">getService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> IActivityManagerSingleton.get();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton&lt;IActivityManager&gt; IActivityManagerSingleton =</span><br><span class="line">    <span class="keyword">new</span> Singleton&lt;IActivityManager&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> IActivityManager <span class="title">create</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">final</span> IBinder b = ServiceManager.getService(Context.ACTIVITY_SERVICE);</span><br><span class="line">            <span class="keyword">final</span> IActivityManager am = IActivityManager.Stub.asInterface(b);</span><br><span class="line">            <span class="keyword">return</span> am;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure></p>
<p>getService()中调用了IActivityManagerSingleton.get()方法，而IAtivityManagerSingleton是一个单例类。<br>这里可以看出IActivityManagerSingleton中采取了AIDL的方式与AMS实现了进程间通信。<br>因此execStartActivity()方法中的代码逻辑实际上走到了AMS的startActivity()</p>
<p><br><br><br></p>
<h2 id="ActivityManagerService"><a href="#ActivityManagerService" class="headerlink" title="ActivityManagerService"></a>ActivityManagerService</h2><p>frameworks/base/services/core/java/com/android/server/am/ActivityManagerService.java<br><strong>ActivityManagerService#startActivity()</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">startActivity</span><span class="params">(IApplicationThread caller, String callingPackage,</span></span></span><br><span class="line"><span class="function"><span class="params">	Intent intent, String resolvedType, IBinder resultTo, String resultWho, <span class="keyword">int</span> requestCode, <span class="keyword">int</span> startFlags, ProfilerInfo profilerInfo, Bundle bOptions)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> startActivityAsUser(caller, callingPackage, intent, resolvedType, resultTo,</span><br><span class="line">            resultWho, requestCode, startFlags, profilerInfo, bOptions,</span><br><span class="line">            UserHandle.getCallingUserId());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">startActivityAsUser</span><span class="params">(IApplicationThread caller, String callingPackage,</span></span></span><br><span class="line"><span class="function"><span class="params">    Intent intent, String resolvedType, IBinder resultTo, String resultWho, <span class="keyword">int</span> requestCode, <span class="keyword">int</span> startFlags, ProfilerInfo profilerInfo, Bundle bOptions, <span class="keyword">int</span> userId)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//判断调用者进程是否被隔离，若是，则会抛出SecurityException异常</span></span><br><span class="line">	enforceNotIsolatedCaller(<span class="string">"startActivity"</span>);</span><br><span class="line">	<span class="comment">//判断调用者是否有权限</span></span><br><span class="line">    userId = mUserController.handleIncomingUser(Binder.getCallingPid(), Binder.getCallingUid(),userId, <span class="keyword">false</span>, ALLOW_FULL_ONLY, <span class="string">"startActivity"</span>, <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">return</span> mActivityStarter.startActivityMayWait(caller, -<span class="number">1</span>, callingPackage,intent,resolvedType, <span class="keyword">null</span>, <span class="keyword">null</span>, resultTo, resultWho, requestCode, startFlags,</span><br><span class="line">		profilerInfo, <span class="keyword">null</span>, <span class="keyword">null</span>, bOptions, <span class="keyword">false</span>, userId, <span class="keyword">null</span>, <span class="string">"startActivityAsUser"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p></p><p align="left">在startActivity()中return了startActivityAsUser()方法，其中多了一个参数，</p><br><strong>UserHandle.getCallingUserId()</strong>,这个参数会获取调用者的UserId，AMS根据UserId确定调用者的权限。最后逻辑转移到了ActivityStarter类。<p></p>
<p>//========================分割线 ==========================//</p>
<p>接下来的逻辑可能会引起各位看官的强烈不适，但不管怎样还是要坚持看完。<br>以下内容涉及到ActivityStarter.java, ActivityStackSupervisor.java,ActivityStack.java以及ActivityThread.java,接下来慢慢分析这几个类的作用。</p>
<p><br><br><br></p>
<h2 id="ActivityStarter"><a href="#ActivityStarter" class="headerlink" title="ActivityStarter"></a>ActivityStarter</h2><p>ActivityStarter是加载Activity的控制类，收集所有的逻辑来决定如何将Intent和Flags转为Activity并将其与Task和Stack关联。<br><strong>ActivityStarter# startActivityMayWait()</strong><br>frameworks/base/services/core/java/com/android/server/am/ActivityStarter.java<br>ActivityStarter的调用流程：</p>
<ol>
<li>startActivityMayWait()</li>
<li>startActivityLocked()</li>
<li>startActivity()</li>
<li>startActivityUnchecked()</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> startActivityMayWait（……）&#123;</span><br><span class="line">  <span class="comment">//……省略代码</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//根据Intent获取到Activity的信息</span></span><br><span class="line">  <span class="comment">//当我们启动一个Activity时，Intent可以是显式的，也可以是隐式的。当Intent是显式时，//Intent已经有了目标Activity的信息，但如果是隐式的，就需要用过ActivityStackSupervisor</span></span><br><span class="line">  <span class="comment">//的resolveActivity来匹配了。</span></span><br><span class="line">  ActivityInfo aInfo = mSupervisor.resolveActivity(intent, rInfo, startFlags, profilerInfo);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//……省略代码</span></span><br><span class="line">  <span class="keyword">int</span> res = startActivityLocked(caller, intent, ephemeralIntent, resolvedType,</span><br><span class="line">              aInfo, rInfo, voiceSession, voiceInteractor,resultTo, resultWho, requestCode, callingPid,</span><br><span class="line">              callingUid, callingPackage, realCallingPid, realCallingUid, startFlags,</span><br><span class="line">              options, ignoreTargetSecurity, componentSpecified, outRecord, inTask,reason);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在ActivityStarter#startActivityLocked()里会调用ActivityStarter#startActivity()，在这里创建了ActivityRecord对象，存储Activity的重要信息。</p>
<p><br><br><strong>ActivityStarter#startActivity()</strong><br>这个方法是不能被外界调用的，必须通过startActivityLocked来调用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">startActivity</span><span class="params">(<span class="comment">/*省略参数*/</span>)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> err = ActivityManager.START_SUCCESS;</span><br><span class="line">    <span class="comment">// Pull the optional Ephemeral Installer-only bundle out of the options early.</span></span><br><span class="line">   <span class="keyword">final</span> Bundle verificationBundle</span><br><span class="line">            = options != <span class="keyword">null</span> ? options.popAppVerificationBundle() : <span class="keyword">null</span>;</span><br><span class="line">   ProcessRecord callerApp = <span class="keyword">null</span>;</span><br><span class="line">   <span class="comment">//先判断caller进程是否还存在，</span></span><br><span class="line">   <span class="comment">//可能caller进程在发出启动请求后就被系统kill掉了</span></span><br><span class="line">   <span class="comment">//获取调用者进程并得到进程pid和uid</span></span><br><span class="line">    <span class="keyword">if</span> (caller != <span class="keyword">null</span>) &#123;</span><br><span class="line">        callerApp = mService.getRecordForAppLocked(caller);</span><br><span class="line">        <span class="keyword">if</span> (callerApp != <span class="keyword">null</span>)</span><br><span class="line">            callingPid = callerApp.pid;</span><br><span class="line">            callingUid = callerApp.info.uid;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ……</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">/*省略代码*/</span></span><br><span class="line">	<span class="comment">//在APP组件能运行之前，如果需要review权限的话会执行这段代码</span></span><br><span class="line">	<span class="comment">//跟ActivityManagerService的mPermissionReviewRequired这个布尔值有关</span></span><br><span class="line">	<span class="comment">//由于本人水平有限，故没有继续深入分析</span></span><br><span class="line">	<span class="keyword">if</span> (mService.mPermissionReviewRequired &amp;&amp; aInfo != <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="comment">/*省略代码*/</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//这里创建了一个ActivityRecord,这是一个Activity的描述类,封装了很多Activity信息</span></span><br><span class="line">	<span class="comment">//官方这样解释：</span></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * An entry in the history stack, representing an activity.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line"></span><br><span class="line">	 ActivityRecord r = <span class="keyword">new</span> ActivityRecord(mService, callerApp, callingPid, callingUid, callingPackage, intent,  </span><br><span class="line">    resolvedType, aInfo, mService.getGlobalConfiguration(), resultRecord, resultWho, requestCode,   </span><br><span class="line">    componentSpecified, voiceSession != <span class="keyword">null</span>, mSupervisor, options, sourceRecord);</span><br><span class="line">	<span class="comment">//该函数内部会启动因app switch禁用而被hold而等待启动Activity的//Pending请求</span></span><br><span class="line">	doPendingActivityLaunchesLocked(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> startActivity(<span class="comment">/*ActivityRecord*/</span>r, sourceRecord, voiceSession, voiceInteractor, startFlags,   </span><br><span class="line">    <span class="keyword">true</span>, options, inTask, outActivity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在startActivity()重载方法里会执行<br><strong>ActivityStarter# startActivityUnchecked()</strong><br>该方法中会涉及到Android的启动模式和位运算，如果对位运算不熟悉的可以 <a href="https://blog.csdn.net/zzp16/article/details/7956768" target="_blank" rel="noopener">点我</a> 来加深印象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">startActivityUnchecked</span><span class="params">(<span class="keyword">final</span> ActivityRecord r, ActivityRecord sourceRecord,</span></span></span><br><span class="line"><span class="function"><span class="params">    IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor, <span class="keyword">int</span> startFlags,</span></span></span><br><span class="line"><span class="function"><span class="params">                                   <span class="keyword">boolean</span> doResume, ActivityOptions options, TaskRecord inTask,</span></span></span><br><span class="line"><span class="function"><span class="params">                                   ActivityRecord[] outActivity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//该方法会校验Intent的Flag是否是特定的Flag，</span></span><br><span class="line">    <span class="comment">//会涉及到各种启动模式和Android的位运算</span></span><br><span class="line">    setInitialState(r, options, inTask, doResume, startFlags, sourceRecord, voiceSession,</span><br><span class="line">            voiceInteractor);</span><br><span class="line">    <span class="comment">//判断是否需要启动新的task</span></span><br><span class="line">    computeLaunchingTaskFlags();</span><br><span class="line">    <span class="comment">//记录父Activity对应的TaskRecord信息</span></span><br><span class="line">    computeSourceStack();</span><br><span class="line">    mIntent.setFlags(mLaunchFlags);</span><br><span class="line">    <span class="comment">//决定是否将新Activity插入到现有的Task中</span></span><br><span class="line">    ActivityRecord reusedActivity = getReusableIntentActivity();</span><br><span class="line">    <span class="comment">//从ActivityOptions参数中得到将Activity加入Task对应的StackId</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> preferredLaunchStackId = (mOptions != <span class="keyword">null</span>) ? mOptions.getLaunchStackId() : INVALID_STACK_ID;</span><br><span class="line">    <span class="comment">/* 当新Activity插入到现有Task时的处理过程,</span></span><br><span class="line"><span class="comment">    *  经过Debug发现，从桌面启动Activity，这里reusedActivity == null</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">if</span> (reusedActivity != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//……省略代码</span></span><br><span class="line">        <span class="comment">//处理各种Flag的情况</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//……</span></span><br><span class="line">    <span class="comment">//权限检查,验证Intent中Uri权限</span></span><br><span class="line">    mService.grantUriPermissionFromIntentLocked(mCallingUid, mStartActivity.packageName, mIntent, mStartActivity.getUriPermissionsLocked(), mStartActivity.userId);</span><br><span class="line">    mService.grantEphemeralAccessLocked(mStartActivity.userId, mIntent, mStartActivity.appInfo.uid, UserHandle.getAppId(mCallingUid));</span><br><span class="line">    <span class="comment">//任务栈历史栈配置</span></span><br><span class="line">    <span class="comment">// 处理和WindowManagerService之间的交互</span></span><br><span class="line">    <span class="comment">//保证Activity对应的UI能在屏幕上显示出来</span></span><br><span class="line">    mTargetStack.startActivityLocked(mStartActivity, topFocused, newTask, mKeepCurTransition, mOptions);</span><br><span class="line">    <span class="keyword">if</span> (mDoResume) &#123;</span><br><span class="line">        <span class="keyword">final</span> ActivityRecord topTaskActivity =</span><br><span class="line">                mStartActivity.getTask().topRunningActivityLocked();</span><br><span class="line">        <span class="keyword">if</span> (!mTargetStack.isFocusable()</span><br><span class="line">                || (topTaskActivity != <span class="keyword">null</span> &amp;&amp; topTaskActivity.mTaskOverlay</span><br><span class="line">                &amp;&amp; mStartActivity != topTaskActivity)) &#123;</span><br><span class="line">            <span class="comment">//目标Task的focusable为false或者源Task栈顶Activity总是在其他Activity之上</span></span><br><span class="line">            <span class="comment">//不恢复目标Task，只需确保它可见</span></span><br><span class="line">            mTargetStack.ensureActivitiesVisibleLocked(<span class="keyword">null</span>, <span class="number">0</span>, !PRESERVE_WINDOWS);</span><br><span class="line">            <span class="comment">//通过WindowManagerService执行app启动动画</span></span><br><span class="line">            mWindowManager.executeAppTransition();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//如果目标栈之前不是可聚焦状态，那么将目标栈变为可聚焦</span></span><br><span class="line">            <span class="keyword">if</span> (mTargetStack.isFocusable( &amp;&amp; !mSupervisor.isFocusedStack(mTargetStack)) &#123;</span><br><span class="line">                mTargetStack.moveToFront(<span class="string">"startActivityUnchecked"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">    <span class="comment">//======== 注释1 ========</span></span><br><span class="line">    <span class="comment">//通过ActivityStackSupervisor来恢复目标task</span></span><br><span class="line">            mSupervisor.resumeFocusedStackTopActivityLocked(mTargetStack, mStartActivity, mOptions);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//如果不需要恢复，则将Activity加入到最近活动栈中</span></span><br><span class="line">        mTargetStack.addRecentActivityLocked(mStartActivity);</span><br><span class="line">    &#125;</span><br><span class="line">    ……</span><br><span class="line">    <span class="keyword">return</span> START_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结来讲startActivityUnchecked主要是处理栈配置和管理相关的逻辑。</p>
<p><br><br><br></p>
<h2 id="ActivityStackSupervisor、ActivityStack"><a href="#ActivityStackSupervisor、ActivityStack" class="headerlink" title="ActivityStackSupervisor、ActivityStack"></a>ActivityStackSupervisor、ActivityStack</h2><p>frameworks/base/services/core/java/com/android/server/am/ActivityStackSupervisor.java<br>frameworks/base/services/core/java/com/android/server/am/ActivityStack.java<br>见ActivityStarter# startActivityUnchecked() 的注释1，新开启的Activity会调用<br><strong>ActivityStackSupervisor #resumeFocusedStackTopActivityLocked().</strong></p>
<p>接下来是ActivityStackSupervisor.java，相信你看到这里已经眼花缭乱了，其实我也一样，为了研究Activity的启动流程，不得不坚持 read the fucking source code.<br>什么？讲脏话？NO，NO，不存在的。<img src="https://img-blog.csdn.net/20180412205851934?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuY2xlUG9tZWxv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="世界如此美好"></p>
<p>简单说一下ActivityStack和ActivityStackSupervisor这两个类吧。<br><strong>ActivityStack</strong>：负责管理在Stack和Task中的Activity<br><strong>ActivityStackSupervisor</strong>：负责管理Stack和Task的操作，可以理解为管理ActivityStack<br>两者相互调用, 最终完成启动Activity。</p>
<p>看看这两个类中的代码是如何调用的。是不是有点想骂*(手动屏蔽)的冲动。<br>ActivityStackSupervisor#resumeFocusedStackTopActivityLocked() -&gt;<br>ActivityStack#resumeTopActivityUncheckedLocked()-&gt;<br>ActivityStack#resumeTopActivityInnerLocked()-&gt;<br>ActivityStackSupervisor# startSpecificActivityLocked ()-&gt;<br>ActivityStackSupervisor # realStartActivityLocked ()</p>
<p>重点看看<strong>ActivityStack#resumeTopActivityInnerLocked()</strong><br>在使用Android Studio进行代码跟踪，发现走的是以下流程。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">resumeTopActivityInnerLocked</span><span class="params">(ActivityRecord prev, ActivityOptions options)</span></span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ActivityRecord next = topRunningActivityLocked(<span class="keyword">true</span> <span class="comment">/* focusableOnly */</span>);</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> hasRunningActivity = next != <span class="keyword">null</span>;</span><br><span class="line">    mStackSupervisor.cancelInitializingActivities();</span><br><span class="line">    ……</span><br><span class="line">    <span class="comment">//重点看这里，这里调用了StackSupervisor# pauseBackStacks方法,</span></span><br><span class="line">    <span class="comment">//该方法会遍历所有任务栈，并调用ActivityStack#startPausingLocked()</span></span><br><span class="line">    <span class="comment">//暂停处于栈内的所有Activity</span></span><br><span class="line">    <span class="keyword">boolean</span> pausing = mStackSupervisor.pauseBackStacks(userLeaving, next, <span class="keyword">false</span>);</span><br><span class="line">    <span class="keyword">if</span> (next.app != <span class="keyword">null</span> &amp;&amp; next.app.thread != <span class="keyword">null</span>) &#123;</span><br><span class="line">    ……</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//调用了ActivityStackSupervisor# startSpecificActivityLocked</span></span><br><span class="line">    mStackSupervisor.startSpecificActivityLocked(next, <span class="keyword">true</span>, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>ActivityStackSupervisor# startSpecificActivityLocked()</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">startSpecificActivityLocked</span><span class="params">(ActivityRecord r,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 <span class="keyword">boolean</span> andResume, <span class="keyword">boolean</span> checkConfig)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//这里根据processName和UID在系统中查找是否已经有相应的进程存在</span></span><br><span class="line">    <span class="comment">//如果之前app进程不存在，则app=null</span></span><br><span class="line">    ProcessRecord app = mService.getProcessRecordLocked(r.processName,</span><br><span class="line">            r.info.applicationInfo.uid, <span class="keyword">true</span>);</span><br><span class="line">    r.getStack().setLaunchTime(r);</span><br><span class="line">    <span class="keyword">if</span> (app != <span class="keyword">null</span> &amp;&amp; app.thread != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> ((r.info.flags&amp; ActivityInfo.FLAG_MULTIPROCESS) == <span class="number">0</span></span><br><span class="line">                    || !<span class="string">"android"</span>.equals(r.info.packageName)) &#123;</span><br><span class="line">                <span class="comment">//向PreocessRecord中增加对应的package信息</span></span><br><span class="line">                app.addPackage(r.info.packageName, r.info.applicationInfo.versionCode,</span><br><span class="line">                        mService.mProcessStats);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//======== 注释2 ========</span></span><br><span class="line">            <span class="comment">//若app进程存在，通知进程启动目标Activity</span></span><br><span class="line">            realStartActivityLocked(r, app, andResume, checkConfig);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">            Slog.w(TAG, <span class="string">"Exception when starting activity "</span></span><br><span class="line">                    + r.intent.getComponent().flattenToShortString(), e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//======== 注释3 ========</span></span><br><span class="line">    <span class="comment">//若进程不存在，则使用AMS开启一个新进程</span></span><br><span class="line">    mService.startProcessLocked(r.processName, r.info.applicationInfo, <span class="keyword">true</span>, <span class="number">0</span>,<span class="string">"activity"</span>, r.intent.getComponent(), <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>这里有两种情况</strong>，<br>①    注释2处:创建activity之前进程存在，则会执行realStartActivityLocked()<br>②    注释3处:创建activity之前进程不存在,ActivityManagerService会调用startProcessLocked()方法创建一个新进程。</p>
<p>先来看第一种情况:<br><strong>ActivityStackSupervisor#realStartActivityLocked()</strong><br>见名知意，这里应该就是真正启动Activity的地方。难道到这里就结束了吗？并不是的，具体还请各位看官继续往下翻。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">realStartActivityLocked</span><span class="params">(ActivityRecord r, ProcessRecord app,</span></span></span><br><span class="line"><span class="function"><span class="params">                                      <span class="keyword">boolean</span> andResume, <span class="keyword">boolean</span> checkConfig)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">    <span class="comment">//获得已存在的Task和Stack</span></span><br><span class="line">    <span class="keyword">final</span> TaskRecord task = r.getTask();</span><br><span class="line">    <span class="keyword">final</span> ActivityStack stack = task.getStack();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//推迟resume，避免在一个循环中多次resume</span></span><br><span class="line">    beginDeferResume();</span><br><span class="line">    <span class="comment">//开始冻结屏幕</span></span><br><span class="line">    r.startFreezingScreenLocked(app, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">//开始收集启动信息</span></span><br><span class="line">    r.startLaunchTickingLocked();</span><br><span class="line">    r.app = app;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (checkConfig) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> displayId = r.getDisplayId();</span><br><span class="line">        <span class="keyword">final</span> Configuration config =mWindowManager.updateOrientationFromAppTokens(</span><br><span class="line">                getDisplayOverrideConfiguration(displayId),r.mayFreezeScreenLocked(app) ? r.appToken : <span class="keyword">null</span>, displayId);</span><br><span class="line">        <span class="comment">//当显示方向改变时，推迟resume，防止启动多余的Activity</span></span><br><span class="line">        mService.updateDisplayOverrideConfigurationLocked(config, r, <span class="keyword">true</span> <span class="comment">/* deferResume */</span>,displayId);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//更新进程使用情况</span></span><br><span class="line">    mService.updateLruProcessLocked(app, <span class="keyword">true</span>, <span class="keyword">null</span>);</span><br><span class="line">    <span class="comment">//更新进程OomAdj</span></span><br><span class="line">    mService.updateOomAdjLocked();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//如果ProcessRecord为空，则抛异常</span></span><br><span class="line">        <span class="keyword">if</span> (app.thread == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RemoteException();</span><br><span class="line">        &#125;</span><br><span class="line">         ……</span><br><span class="line">        <span class="comment">//更新package最后一次使用的时间</span></span><br><span class="line">        mService.notifyPackageUse(r.intent.getComponent().getPackageName(),</span><br><span class="line">                PackageManager.NOTIFY_PACKAGE_USE_ACTIVITY);</span><br><span class="line">        app.forceProcessStateUpTo(mService.mTopProcessState);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//官方解释：可能用户是从系统进程启动的Activity,如果那样的话就不会走到//用来创建新配置的Binder接口,因此先在这里创建一个配置</span></span><br><span class="line">        <span class="keyword">final</span> MergedConfiguration mergedConfiguration = <span class="keyword">new</span> MergedConfiguration(</span><br><span class="line">                mService.getGlobalConfiguration(), r.getMergedOverrideConfiguration());</span><br><span class="line">        r.setLastReportedConfiguration(mergedConfiguration);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//通过Binder调用ApplicationThread的scheduleLaunchActivity()</span></span><br><span class="line">        app.thread.scheduleLaunchActivity(<span class="keyword">new</span> Intent(r.intent), r.appToken, System.identityHashCode(r),r.info,mergedConfiguration.getGlobalConfiguration(),mergedConfiguration.getOverrideConfiguration(), r.compat,</span><br><span class="line">                r.launchedFromPackage, task.voiceInteractor, app.repProcState, r.icicle,</span><br><span class="line">                r.persistentState, results, newIntents, !andResume,</span><br><span class="line">                mService.isNextTransitionForward(), profilerInfo);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// …… 处理进程臃肿的情况</span></span><br><span class="line">    &#125; <span class="keyword">catch</span>(RemoteException e)&#123;</span><br><span class="line">        ……</span><br><span class="line">        <span class="comment">//会进行两次操作，第一次重启进程失败后再抛出异常执行第二次操作</span></span><br><span class="line">        <span class="comment">//第二次失败后就放弃</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>realStartActivityLocked方法主要干了两件事：<br>①    更新AMS中各种配置<br>②    调用ApplicationThread# scheduleLaunchActivity()启动Activity</p>
<p><strong>ActivityStackSupervisor#realStartActivityLocked()</strong>结束<br>ApplicationThread# scheduleLaunchActivity()的情况以及第二种进程未启动的情况将在第三篇文章为各位看官分析进程的创建和启动,敬请期待。<br>想直接看第三篇的朋友 <a href="https://pomelojiang.github.io/android_framework_start_activity_3">请点我</a></p>
<p>下一篇：<a href="https://pomelojiang.github.io/android_framework_start_activity_2">Android Framework之Activity启动流程(二)</a></p>
<p><br><br><br></p>
<p>参考：<br><a href="https://blog.csdn.net/chenkai19920410/article/details/54344295" target="_blank" rel="noopener">https://blog.csdn.net/chenkai19920410/article/details/54344295</a><br><a href="https://blog.csdn.net/gaugamela/article/details/53183216" target="_blank" rel="noopener">https://blog.csdn.net/gaugamela/article/details/53183216</a><br><a href="https://blog.csdn.net/Gaugamela/article/details/53895040" target="_blank" rel="noopener">https://blog.csdn.net/Gaugamela/article/details/53895040</a></p>

        
    </section>
</article>



<div class="comments">
    <div id="comments"></div>
    <script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>
    <script>
    new Gitalk({
        clientID: "1d3d074e112b21d4b16b",
        clientSecret: "6cf434c1ab62299c7424dc86f574505eb2c1d175",
        repo: "pomelojiang.github.io",
        owner: "pomelojiang",
        admin: ["pomelojiang"],
        id: "android_framework_start_activity_1.html",
        distractionFreeMode: true,
        title: "Android Framework之Activity启动流程(一)",
        body: "http://pomelojiang.github.io/android_framework_start_activity_1.html",
        labels: ["Frameworks","Android"]
    }).render('comments');
    </script>
</div>

</div>
        <footer class="footer">
    Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>, Theme by <a href="https://github.com/sanonz/hexo-theme-concise" target="_blank">Concise</a>

    
</footer>

    </main>

    <script type="text/javascript" src="https://cdn.bootcss.com/jquery/1.9.0/jquery.min.js"></script>
    <script type="text/javascript">
    $(function() {
        var nodes = {
            nav: $('#nav'),
            aside: $('#aside'),
            asideInner: $('#aside-inner'),
            navInner: $('#nav-inner')
        };

        var doing = false;
        nodes.asideInner.on('webkitAnimationEnd mozAnimationEnd oAnimationEnd oanimationend animationend', function() {
            if (nodes.aside.hasClass('mobile-open')) {
                nodes.aside.removeClass('mobile-open');
            } else {
                nodes.aside.removeClass('mobile-close panel-show');
            }
            doing = false;
        });
        $('#open-panel, #aside-mask').on('click', function() {
            if (doing) {
                return;
            }
            
            if (nodes.aside.hasClass('panel-show')) {
                nodes.aside.addClass('mobile-close');
            } else {
                nodes.aside.addClass('mobile-open panel-show');
            }
        });
        $('#open-menus').on('click', function() {
            nodes.navInner.slideToggle();
        });

        if (window.innerWidth <= 960) {
            setTimeout(function() {
                nodes.navInner.slideUp();
            }, 3000);
        }
    });
    </script>
    
        <script type="text/javascript" src="/js/scrollspy.min.js"></script>
        <script type="text/javascript">
        $(document.body).scrollspy({target: '#aside-inner'});
        </script>
    

</body>
</html>
